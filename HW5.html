<!DOCTYPE html>
<html>
<head>
<title>HW5.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="homework-5-optimization">Homework 5: Optimization</h1>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> math
<span class="hljs-keyword">from</span> scipy.optimize <span class="hljs-keyword">import</span> minimize
</div></code></pre>
<h2 id="problem-1-interval-bisection-search-and-golden-section-search---1-d-optimization">Problem 1: Interval Bisection Search and Golden Section Search - 1-D Optimization</h2>
<h3 id="definition-of-function-and-its-derivative">Definition of function and its derivative</h3>
<pre class="hljs"><code><div><span class="hljs-comment"># function of x**2</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x2</span><span class="hljs-params">(x)</span>:</span>
    <span class="hljs-keyword">return</span> x**<span class="hljs-number">2</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment"># Derivative of x**2</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x2der</span><span class="hljs-params">(x)</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x
</div></code></pre>
<h3 id="definition-of-ibs-and-gss-method">Definition of IBS and GSS method</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">IBS</span><span class="hljs-params">(derivative, u, l, tol=<span class="hljs-number">10</span>**<span class="hljs-params">(<span class="hljs-number">-4</span>)</span>, maxiter=<span class="hljs-number">50</span>)</span>:</span>
    iteration = <span class="hljs-number">0</span>
    <span class="hljs-comment"># End condition</span>
    <span class="hljs-keyword">while</span> (u - l &gt; tol) <span class="hljs-keyword">and</span> (iteration &lt; maxiter):
        value = derivative( ( u + l ) /<span class="hljs-number">2</span>)
        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span>:
            l = value
        <span class="hljs-keyword">else</span>:
            u = value
            
        iteration += <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> ((u + l) /<span class="hljs-number">2</span>, iteration)
        
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GSS</span><span class="hljs-params">(function, u, l, tol=<span class="hljs-number">10</span>**<span class="hljs-params">(<span class="hljs-number">-4</span>)</span>, maxiter=<span class="hljs-number">50</span>)</span>:</span>
    golden = (<span class="hljs-number">1</span> + <span class="hljs-number">5</span> ** <span class="hljs-number">0.5</span>) / <span class="hljs-number">2</span> <span class="hljs-number">-1</span>
    iteration = <span class="hljs-number">0</span>
    <span class="hljs-comment"># End condition</span>
    <span class="hljs-keyword">while</span> (u - l &gt; tol) <span class="hljs-keyword">and</span> (iteration &lt; maxiter):
        x1 = u - golden*(u - l)
        x2 = l + golden*(u - l)
        value1 = function(x1)
        value2 = function(x2)
        
        <span class="hljs-keyword">if</span> value1 &lt; value2:
            u = x2
        <span class="hljs-keyword">else</span>:
            l = x1
            
        iteration += <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> ((u + l) /<span class="hljs-number">2</span>, iteration)    
</div></code></pre>
<h3 id="50-ibs-and-gss-iterations">50 IBS and GSS iterations</h3>
<pre class="hljs"><code><div>ibs = []
gss = []
maxiterations = <span class="hljs-number">1000</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):
    lower = np.random.uniform(<span class="hljs-number">-10</span>, <span class="hljs-number">0</span>)
    upper = np.random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)
    tolerance = np.random.uniform(<span class="hljs-number">10</span>**(<span class="hljs-number">-8</span>), <span class="hljs-number">0</span>)
    ibs.append(IBS(x2der, upper, lower, tolerance, maxiter=maxiterations)[<span class="hljs-number">1</span>])
    gss.append(GSS(x2, upper, lower, tolerance, maxiter=maxiterations)[<span class="hljs-number">1</span>])

</div></code></pre>
<h3 id="ibs-and-gss-comparison">IBS and GSS comparison</h3>
<pre class="hljs"><code><div>plt.bar(<span class="hljs-string">'IBS'</span>, height= np.log10(np.average(ibs)), color=<span class="hljs-string">'blue'</span>)
plt.bar(<span class="hljs-string">'GSS'</span>, height= np.log10(np.average(gss)), color=<span class="hljs-string">'red'</span>)
plt.xlabel(<span class="hljs-string">'Method'</span>)
plt.ylabel(<span class="hljs-string">'log10 Iterations'</span>)
plt.legend()
</div></code></pre>
<pre><code>No handles with labels found to put in legend.





&lt;matplotlib.legend.Legend at 0x1e2915f6d00&gt;
</code></pre>
<p><img src="output_12_2.png" alt="png"></p>
<h4 id="we-can-clearly-see-that-gss-is-in-faster-than-ibs-for-the-experiment-conducted">We can clearly see that GSS is in faster than IBS for the experiment conducted</h4>
<h2 id="problem-2-convexity-in-1--and-2-dimensions">Problem 2: Convexity in 1- and 2-Dimensions</h2>
<h3 id="1-using-first-and-second-derivatives-confirm-or-reject-that-f-is-convex-fv1%E2%88%92vsup2sup">1. Using first and second derivatives confirm or reject that f is convex f(v)=(1−v)<sup>2</sup></h3>
<h4 id="f---21-v-we-can-see-that-f10-which-corresponds-to-the-minimum-of-f">f' = -2(1-v) we can see that f'(1)=0 which corresponds to the minimum of f.</h4>
<h4 id="f--2-we-can-see-that-f-is-always-positive-through-its-domain-this-implies-that-f-is-convex">f'' = 2 We can see that f'' is always positive through its domain. This implies that f is convex.</h4>
<h4 id="lets-have-a-visual-approach">Let's have a visual approach.</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span>:</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>-x)**<span class="hljs-number">2</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span><span class="hljs-params">(x)</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>*(<span class="hljs-number">1</span>-x)
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span><span class="hljs-params">(x)</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
</div></code></pre>
<pre class="hljs"><code><div>xs = []
fs = []
f1s = []
f2s = []

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):
    x = np.random.uniform(<span class="hljs-number">-3</span>, <span class="hljs-number">5</span>)
    xs.append(x)
    fs.append(f(x))
    f1s.append(f1(x))
    f2s.append(f2(x))

plt.scatter(xs,fs, color=<span class="hljs-string">'blue'</span>, label=<span class="hljs-string">'f'</span>)
plt.scatter(xs, f1s, color=<span class="hljs-string">'red'</span>, label=<span class="hljs-string">"f'"</span>)
plt.scatter(xs, f2s, color=<span class="hljs-string">'magenta'</span>, label=<span class="hljs-string">"f''"</span>)
plt.legend()
</div></code></pre>
<pre><code>&lt;matplotlib.legend.Legend at 0x1e291d561f0&gt;
</code></pre>
<p><img src="output_19_1.png" alt="png"></p>
<h3 id="2-gv-and-hv-are-convex-is-fv--gv--hv-convex">2. g(v) and h(v) are convex, is f(v) = g(v) + h(v) convex?</h3>
<h4 id="since-g-and-h-are-convex-we-have-that-g-and-h-are--0-this-means-that-f--g--h-is-also--0-and-therefore-convex">Since g and h are convex, we have that g'' and h'' are &gt; 0. This means that f'' = g'' + h'' is also &gt; 0 and therefore convex.</h4>
<h3 id="3-gva%E2%88%92vsup2supsup2sup-where-a-is-a-fixed-real-number">3. g(v)=(a−v<sup>2</sup>)<sup>2</sup> where a is a fixed real number.</h3>
<h4 id="g---4va-vsup2sup">g' = -4v(a-v<sup>2</sup>)</h4>
<h4 id="g---4a-3vsup2sup">g'' = -4(a-3v<sup>2</sup>)</h4>
<h4 id="we-want-g--12vsup2sup---4a--0-%E2%86%92-vsup2sup--fraca3-this-means-that-if-a-le-0-g-is-convex-in-re-else-g-is-convex-in-the-ranges-brack--infty-sqrtfraca3-bigcup-brack-sqrtfraca3infty">We want g'' = 12v<sup>2</sup> - 4a  &gt; 0 → v<sup>2</sup> &gt; $\frac{a}{3}$. This means that if  $a \le 0$  g is convex in $\Re$, else g is convex in the ranges $\brack -\infty,-\sqrt{\frac{a}{3}}$ $\bigcup$ $\brack \sqrt{\frac{a}{3}},\infty $.</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g2</span><span class="hljs-params">(x,a)</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-4</span>*(a<span class="hljs-number">-3</span>*x**<span class="hljs-number">2</span>)
</div></code></pre>
<pre class="hljs"><code><div>xs = []
g2s = []

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):
    x = np.random.uniform(<span class="hljs-number">-3</span>, <span class="hljs-number">3</span>)
    xs.append(x)
    g2s.append([g2(x,<span class="hljs-number">-3</span>),g2(x,<span class="hljs-number">-2</span>),g2(x,<span class="hljs-number">-1</span>),g2(x,<span class="hljs-number">0</span>),g2(x,<span class="hljs-number">1</span>),g2(x,<span class="hljs-number">2</span>),g2(x,<span class="hljs-number">3</span>)])

g2s = np.array(g2s)
zeros = np.zeros(len(g2s))
</div></code></pre>
<pre class="hljs"><code><div>plt.scatter(xs, g2s[:,<span class="hljs-number">0</span>], s=<span class="hljs-number">0.5</span>, color=<span class="hljs-string">'blue'</span>, label=<span class="hljs-string">'a=-3'</span>)
plt.scatter(xs, g2s[:,<span class="hljs-number">1</span>], s=<span class="hljs-number">0.5</span>, color=<span class="hljs-string">'red'</span>, label=<span class="hljs-string">'a=-2'</span>)
plt.scatter(xs, g2s[:,<span class="hljs-number">2</span>], s=<span class="hljs-number">0.5</span>, color=<span class="hljs-string">'green'</span>, label=<span class="hljs-string">'a=-1'</span>)
plt.scatter(xs, g2s[:,<span class="hljs-number">3</span>], s=<span class="hljs-number">0.5</span>, color=<span class="hljs-string">'pink'</span>, label=<span class="hljs-string">'a=0'</span>)
plt.scatter(xs, g2s[:,<span class="hljs-number">4</span>], s=<span class="hljs-number">0.5</span>, color=<span class="hljs-string">'black'</span>, label=<span class="hljs-string">'a=1'</span>)
plt.scatter(xs, g2s[:,<span class="hljs-number">5</span>], s=<span class="hljs-number">0.5</span>, color=<span class="hljs-string">'orange'</span>, label=<span class="hljs-string">'a=2'</span>)
plt.scatter(xs, g2s[:,<span class="hljs-number">6</span>], s=<span class="hljs-number">0.5</span>, color=<span class="hljs-string">'yellow'</span>, label=<span class="hljs-string">'a=3'</span>)
plt.scatter(xs, zeros, s=<span class="hljs-number">0.5</span>, color=<span class="hljs-string">'magenta'</span>, label=<span class="hljs-string">'0'</span>)

plt.legend()
</div></code></pre>
<pre><code>&lt;matplotlib.legend.Legend at 0x1e291e33bb0&gt;
</code></pre>
<p><img src="output_24_1.png" alt="png"></p>
<h3 id="4-for-a-vector-vv1-v2t-let-pv1%E2%88%92v12100%E2%88%97v2%E2%88%92v122-calculate-the-gradient-and-hessian-of-p-and-confirm-or-reject-that-p-is-convex-everywhere-in-re2">4. For a vector v=[v1 v2]$^T$, let $p(v)=(1−v_1)^2+100∗(v_2−v_1^2)^2$. Calculate the gradient and Hessian of p, and confirm or reject that p is convex everywhere in $\Re^2$</h3>
<p>$\nabla p = (2 (200 v_1^3 - 200 v_1 v_2 + v_1 - 1), 200 (y - x^2))$</p>
<p>H=$\begin{bmatrix}(-400 (v_2 - v_1^2) + 800 v_1^2 + 2 &amp; -400 v_1\-400 v_1 &amp; 200\end{bmatrix}$</p>
<p>$\lambda_1 = 600 v_1^2 - \sqrt{360000 v_1^4 - 240000 v_1^2 v_2 + 41200 v_1^2 + 40000 v_2^2 + 39600 v_2 + 9801} - 200 v_2 + 101$
$\lambda_2 = 600 v_1^2 + \sqrt{360000 v_1^4 - 240000 v_1^2 v_2 + 41200 v_1^2 + 40000 v_2^2 + 39600 v_2 + 9801} - 200 v_2 + 101$</p>
<p>It is clear that $\lambda_1 \le \lambda_2 $ therefore, we need to find the conditions that fulfill $\lambda_1&gt;0$
$600 v_1^2 - \sqrt{360000 v_1^4 - 240000 v_1^2 v_2 + 41200 v_1^2 + 40000 v_2^2 + 39600 v_2 + 9801} - 200 v_2 + 101 &gt; 0$</p>
<h4 id="finally-p-is-convex-when-v2--frac1200-200-v12--1">Finally, p is convex when $v_2 &lt; \frac{1}{200} (200 v_1^2 + 1)$</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eigen1</span><span class="hljs-params">(x,y)</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">600</span>*x**<span class="hljs-number">2</span> - math.sqrt(<span class="hljs-number">360000</span>*x**<span class="hljs-number">4</span> - <span class="hljs-number">240000</span>*(x**<span class="hljs-number">2</span>)*y + <span class="hljs-number">41200</span>*x**<span class="hljs-number">2</span> + <span class="hljs-number">40000</span>*y**<span class="hljs-number">2</span> + <span class="hljs-number">39600</span>*y + <span class="hljs-number">9801</span>) - <span class="hljs-number">200</span>*y + <span class="hljs-number">101</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eigen2</span><span class="hljs-params">(x,y)</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">600</span>*x**<span class="hljs-number">2</span> + math.sqrt(<span class="hljs-number">360000</span>*x**<span class="hljs-number">4</span> - <span class="hljs-number">240000</span>*(x**<span class="hljs-number">2</span>)*y + <span class="hljs-number">41200</span>*x**<span class="hljs-number">2</span> + <span class="hljs-number">40000</span>*y**<span class="hljs-number">2</span> + <span class="hljs-number">39600</span>*y + <span class="hljs-number">9801</span>) - <span class="hljs-number">200</span>*y + <span class="hljs-number">101</span>
</div></code></pre>
<pre class="hljs"><code><div>x = <span class="hljs-number">1</span>
y = <span class="hljs-number">1</span>
print(eigen1(x,y), eigen2(x,y))
</div></code></pre>
<pre><code>0.3993607674876216 1001.6006392325123
</code></pre>
<pre class="hljs"><code><div>x = []
y = []
min_eigen = []

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">-10</span>,<span class="hljs-number">10</span>):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range (<span class="hljs-number">-10</span>,<span class="hljs-number">100</span>):
        x.append(i)
        y.append(j)
        e1 = eigen1(i,j)
        e2 = eigen2(i,j)
        <span class="hljs-keyword">if</span> e1 &lt; e2:
            min_eigen.append(e1)
        <span class="hljs-keyword">else</span>:
            min_eigen.append(e2)

pos_eigen = [<span class="hljs-number">0</span> <span class="hljs-keyword">if</span> item&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> item==<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> min_eigen]
</div></code></pre>
<h4 id="the-smallest-eigenvalue-appears-to-be-negative-inside-a-parabole-therefore-we-can-conclude-that-p-is-convex-in-the-dark-area-corresponding-to-v2--frac1200-200-v12--1">The smallest eigenvalue, appears to be negative inside a parabole, therefore we can conclude that p is convex in the dark area corresponding to $v_2 &lt; \frac{1}{200} (200 v_1^2 + 1)$</h4>
<pre class="hljs"><code><div>plt.scatter(x, y, c=pos_eigen, cmap=<span class="hljs-string">'Paired'</span>)
plt.xlabel(<span class="hljs-string">'v_1'</span>)
plt.ylabel(<span class="hljs-string">'v_2'</span>)

plt.show()
</div></code></pre>
<p><img src="output_31_0.png" alt="png"></p>
<h2 id="problem-3-nelder-mead-search-and-gradient-descent">Problem 3: Nelder-Mead Search and Gradient Descent</h2>
<h3 id="1-how-nelder-mead-search-works">1. How Nelder-Mead Search works</h3>
<p>Explanation from https://www.youtube.com/watch?v=vOYlVvT3W80 and GIF from http://takashiida.floppy.jp/en/education-2/gif-nelder-mead/
<img src="neldermead.gif" alt="drawing" width="400">
The Nelder-Mead method is a direct search method, meaning that it does not require the computation of the gradient. This makes it very useful for cases where either the gradient is hard to obtain/evaluate or if the function is not smooth. It is based on a n+1 dimension structure called a <em>simplex</em>, for example, if we are in $\Re^2$, it will be a triangle (3 points) and in each iteration, this points are updated. Let's take <strong>u</strong>, <strong>v</strong> and <strong>w</strong> as our three points.</p>
<p>In each iteration, there are 6 steps:</p>
<ol>
<li><strong>Sort</strong>: Sort and label the points according to the function's value $f(u) < f(v) < f(w)$ <strong>u</strong> is the best point and <strong>w</strong> is the worst. <img src="sort.png" alt="drawing" width="200"></li>
<li><strong>Reflect</strong>: Reflect the worst point through the centroid of the two remaining points, point <strong>r</strong>. If $f(r) < f(v)$ but $f(u) < f(r)$, then <strong>w = r</strong>. Now <strong>v</strong> is the worst performing point. Go to step 6: Check for Convergence. <img src="reflect.png" alt="drawing" width="200"></li>
<li><strong>Extend</strong>: If $f(r) < f(u)$ then we extend <strong>r</strong> to <strong>e</strong>. If $f(e) < f(r)$ then <strong>w = e</strong> else <strong>w = r</strong>. Go to step 6: Check for Convergence. <img src="extend.png" alt="drawing" width="200"></li>
<li><strong>Contract</strong>: If $f(r) > f(v)$, <strong>w</strong> is contracted to <strong>c<sub>0</sub></strong> (outside) and <strong>c<sub>i</sub></strong> (inside) where $c_i = \frac{1}{4}(w-r)$ and $c_o = \frac{3}{4}(w-r)$ and evaluate $f(c_o)$ and $f(c_i)$. If either performs better than <strong>v</strong>, then <strong>w</strong> = best performing between <strong>c<sub>0</sub></strong> and <strong>c<sub>i</sub></strong>. Go to step 6: Check for Convergence. <img src="contract.png" alt="drawing" width="200"></li>
<li><strong>Shrink</strong>: If the contracted points do not outperform <strong>v</strong>, then we shrink the simplex towards the <strong>u</strong>, the best performing point with <strong>w = w'</strong> and <strong>v = v'</strong>, where <strong>v'</strong> is the halfway point between <strong>u</strong> and <strong>v</strong> and <strong>w'</strong> is the halfway point between <strong>u</strong> and <strong>w</strong>. Go to step 6: Check for Convergence. <img src="shrink.png" alt="drawing" width="200"> </li>
<li><strong>Check Convergence</strong>: There are many ways to check convergence, but a common one is to check whether the standard deviation between the points of the simplex is below some pre defined tolerance. </li>
</ol>
<h3 id="2-nelder-mead-nma-and-conjugate-gradient-descent-cg">2. Nelder-Mead (NMA) and Conjugate Gradient Descent (CG)</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">objective_p</span><span class="hljs-params">(x)</span>:</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> - x[<span class="hljs-number">0</span>])**<span class="hljs-number">2</span> + <span class="hljs-number">100</span>*(x[<span class="hljs-number">1</span>] - x[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>
</div></code></pre>
<pre class="hljs"><code><div>maxiterations = <span class="hljs-number">5</span>
optimizer = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]

NMA_distance = []
CG_distance = []

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
    p1 = [np.around([np.random.uniform(<span class="hljs-number">-3</span>, <span class="hljs-number">12</span>)], decimals=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>], np.around([np.random.uniform(<span class="hljs-number">-6</span>, <span class="hljs-number">60</span>)])[<span class="hljs-number">0</span>]]
    p2 = [np.around([np.random.uniform(<span class="hljs-number">-3</span>, <span class="hljs-number">12</span>)], decimals=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>], np.around([np.random.uniform(<span class="hljs-number">-6</span>, <span class="hljs-number">60</span>)])[<span class="hljs-number">0</span>]]
    p3 = [np.around([np.random.uniform(<span class="hljs-number">-3</span>, <span class="hljs-number">12</span>)], decimals=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>], np.around([np.random.uniform(<span class="hljs-number">-6</span>, <span class="hljs-number">60</span>)])[<span class="hljs-number">0</span>]]
    pt = [p1, p2, p3]
    
    NMA = minimize(objective_p, pt, method=<span class="hljs-string">'nelder-mead'</span>, options={<span class="hljs-string">'maxiter'</span>:maxiterations})
    CG = minimize(objective_p, pt, method=<span class="hljs-string">'CG'</span>, options={<span class="hljs-string">'maxiter'</span>:maxiterations})
    
    <span class="hljs-comment"># evaluate solutions</span>
    solution_NMA = NMA[<span class="hljs-string">'x'</span>]
    evaluation_NMA = objective_p(solution_NMA)
    
    <span class="hljs-comment"># euclidean distance</span>
    NMA_distance.append((solution_NMA[<span class="hljs-number">0</span>] - optimizer[<span class="hljs-number">0</span>])**<span class="hljs-number">2</span> + (solution_NMA[<span class="hljs-number">1</span>] - optimizer[<span class="hljs-number">1</span>])**<span class="hljs-number">2</span>)
    
    solution_CG = CG[<span class="hljs-string">'x'</span>]
    evaluation_CG = objective_p(solution_CG)
    CG_distance.append((solution_CG[<span class="hljs-number">0</span>] - optimizer[<span class="hljs-number">0</span>])**<span class="hljs-number">2</span> + (solution_CG[<span class="hljs-number">1</span>] - optimizer[<span class="hljs-number">1</span>])**<span class="hljs-number">2</span>)
    
</div></code></pre>
<pre class="hljs"><code><div>
</div></code></pre>

</body>
</html>
